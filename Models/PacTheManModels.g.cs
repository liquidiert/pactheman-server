//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
//
// This source code was auto-generated by bebopc, Version=2.0.3.
//
namespace PacTheMan.Models {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostAlgorithms : System.IEquatable<BaseGhostAlgorithms> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Blinky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Clyde { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Inky { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Pinky { get; set; }

    public bool Equals(BaseGhostAlgorithms other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Blinky == other.Blinky && Clyde == other.Clyde && Inky == other.Inky && Pinky == other.Pinky;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostAlgorithms baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Blinky.GetHashCode();
      hash ^= Clyde.GetHashCode();
      hash ^= Inky.GetHashCode();
      hash ^= Pinky.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostAlgorithms left, BaseGhostAlgorithms right) => Equals(left, right);
    public static bool operator !=(BaseGhostAlgorithms left, BaseGhostAlgorithms  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostAlgorithms : BaseGhostAlgorithms {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostAlgorithms record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostAlgorithms record, ref BebopWriter writer) {
      writer.WriteString(record.Blinky);
      writer.WriteString(record.Clyde);
      writer.WriteString(record.Inky);
      writer.WriteString(record.Pinky);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostAlgorithms, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostAlgorithms Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostAlgorithms DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new GhostAlgorithms {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostAlgorithms, new() {
      string field0;
      field0 = reader.ReadString();
      string field1;
      field1 = reader.ReadString();
      string field2;
      field2 = reader.ReadString();
      string field3;
      field3 = reader.ReadString();
      return new T {
        Blinky = field0,
        Clyde = field1,
        Inky = field2,
        Pinky = field3,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostState : System.IEquatable<BaseGhostState> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> Targets { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, bool> ClearTargets { get; set; }

    public bool Equals(BaseGhostState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Targets is null ? other.Targets is null : other.Targets is not null && Targets.SequenceEqual(other.Targets)) && (ClearTargets is null ? other.ClearTargets is null : other.ClearTargets is not null && ClearTargets.SequenceEqual(other.ClearTargets));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Targets.GetHashCode();
      hash ^= ClearTargets.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostState left, BaseGhostState right) => Equals(left, right);
    public static bool operator !=(BaseGhostState left, BaseGhostState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostState : BaseGhostState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostState record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.Targets.Count));
      foreach (var kv0 in record.Targets) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.ClearTargets.Count));
      foreach (var kv0 in record.ClearTargets) {
        writer.WriteString(kv0.Key);
        writer.WriteByte(kv0.Value);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostState DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, bool> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, bool>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          bool v0;
          k0 = reader.ReadString();
          v0 = reader.ReadByte() != 0;
          field1.Add(k0, v0);
        }
      }
      return new GhostState {
        Targets = field0,
        ClearTargets = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostState, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, bool> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, bool>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          bool v0;
          k0 = reader.ReadString();
          v0 = reader.ReadByte() != 0;
          field1.Add(k0, v0);
        }
      }
      return new T {
        Targets = field0,
        ClearTargets = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseInitState : System.IEquatable<BaseInitState> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostInitVelocities { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, uint> GhostInitDelays { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerInitPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, uint> PlayerInitScores { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, uint> PlayerInitLives { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BasePosition[] ScorePointsInitPositions { get; set; }

    public bool Equals(BaseInitState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (GhostInitPositions is null ? other.GhostInitPositions is null : other.GhostInitPositions is not null && GhostInitPositions.SequenceEqual(other.GhostInitPositions)) && (GhostInitVelocities is null ? other.GhostInitVelocities is null : other.GhostInitVelocities is not null && GhostInitVelocities.SequenceEqual(other.GhostInitVelocities)) && (GhostInitDelays is null ? other.GhostInitDelays is null : other.GhostInitDelays is not null && GhostInitDelays.SequenceEqual(other.GhostInitDelays)) && (PlayerInitPositions is null ? other.PlayerInitPositions is null : other.PlayerInitPositions is not null && PlayerInitPositions.SequenceEqual(other.PlayerInitPositions)) && (PlayerInitScores is null ? other.PlayerInitScores is null : other.PlayerInitScores is not null && PlayerInitScores.SequenceEqual(other.PlayerInitScores)) && (PlayerInitLives is null ? other.PlayerInitLives is null : other.PlayerInitLives is not null && PlayerInitLives.SequenceEqual(other.PlayerInitLives)) && (ScorePointsInitPositions is null ? other.ScorePointsInitPositions is null : other.ScorePointsInitPositions is not null && ScorePointsInitPositions.SequenceEqual(other.ScorePointsInitPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseInitState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= GhostInitPositions.GetHashCode();
      hash ^= GhostInitVelocities.GetHashCode();
      hash ^= GhostInitDelays.GetHashCode();
      hash ^= PlayerInitPositions.GetHashCode();
      hash ^= PlayerInitScores.GetHashCode();
      hash ^= PlayerInitLives.GetHashCode();
      hash ^= ScorePointsInitPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseInitState left, BaseInitState right) => Equals(left, right);
    public static bool operator !=(BaseInitState left, BaseInitState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class InitState : BaseInitState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseInitState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseInitState record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.GhostInitPositions.Count));
      foreach (var kv0 in record.GhostInitPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.GhostInitVelocities.Count));
      foreach (var kv0 in record.GhostInitVelocities) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.GhostInitDelays.Count));
      foreach (var kv0 in record.GhostInitDelays) {
        writer.WriteString(kv0.Key);
        writer.WriteUInt32(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitPositions.Count));
      foreach (var kv0 in record.PlayerInitPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitScores.Count));
      foreach (var kv0 in record.PlayerInitScores) {
        writer.WriteGuid(kv0.Key);
        writer.WriteUInt32(kv0.Value);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerInitLives.Count));
      foreach (var kv0 in record.PlayerInitLives) {
        writer.WriteGuid(kv0.Key);
        writer.WriteUInt32(kv0.Value);
      }
      {
        var length0 = unchecked((uint)record.ScorePointsInitPositions.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          PacTheMan.Models.Position.EncodeInto(record.ScorePointsInitPositions[i0], ref writer);
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseInitState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static InitState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static InitState DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, uint> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<string, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          uint v0;
          k0 = reader.ReadString();
          v0 = reader.ReadUInt32();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, uint> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          uint v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadUInt32();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, uint> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<System.Guid, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          uint v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadUInt32();
          field5.Add(k0, v0);
        }
      }
      BasePosition[] field6;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field6 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field6[i0] = x0;
        }
      }
      return new InitState {
        GhostInitPositions = field0,
        GhostInitVelocities = field1,
        GhostInitDelays = field2,
        PlayerInitPositions = field3,
        PlayerInitScores = field4,
        PlayerInitLives = field5,
        ScorePointsInitPositions = field6,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseInitState, new() {
      System.Collections.Generic.Dictionary<string, BasePosition> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<string, uint> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<string, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          uint v0;
          k0 = reader.ReadString();
          v0 = reader.ReadUInt32();
          field2.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field3;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field3 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field3.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, uint> field4;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field4 = new System.Collections.Generic.Dictionary<System.Guid, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          uint v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadUInt32();
          field4.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, uint> field5;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field5 = new System.Collections.Generic.Dictionary<System.Guid, uint>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          uint v0;
          k0 = reader.ReadGuid();
          v0 = reader.ReadUInt32();
          field5.Add(k0, v0);
        }
      }
      BasePosition[] field6;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field6 = new BasePosition[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          BasePosition x0;
          x0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field6[i0] = x0;
        }
      }
      return new T {
        GhostInitPositions = field0,
        GhostInitVelocities = field1,
        GhostInitDelays = field2,
        PlayerInitPositions = field3,
        PlayerInitScores = field4,
        PlayerInitLives = field5,
        ScorePointsInitPositions = field6,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BasePlayerState : System.IEquatable<BasePlayerState> {
    public const uint OpCode = 0x5;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<string, BasePosition> GhostPositions { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BasePosition> PlayerPositions { get; set; }

    public bool Equals(BasePlayerState other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && (GhostPositions is null ? other.GhostPositions is null : other.GhostPositions is not null && GhostPositions.SequenceEqual(other.GhostPositions)) && (PlayerPositions is null ? other.PlayerPositions is null : other.PlayerPositions is not null && PlayerPositions.SequenceEqual(other.PlayerPositions));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePlayerState baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      hash ^= GhostPositions.GetHashCode();
      hash ^= PlayerPositions.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePlayerState left, BasePlayerState right) => Equals(left, right);
    public static bool operator !=(BasePlayerState left, BasePlayerState  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class PlayerState : BasePlayerState {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePlayerState record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePlayerState record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      writer.WriteUInt32(unchecked((uint)record.GhostPositions.Count));
      foreach (var kv0 in record.GhostPositions) {
        writer.WriteString(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
      writer.WriteUInt32(unchecked((uint)record.PlayerPositions.Count));
      foreach (var kv0 in record.PlayerPositions) {
        writer.WriteGuid(kv0.Key);
        PacTheMan.Models.Position.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePlayerState, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static PlayerState Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static PlayerState DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field2.Add(k0, v0);
        }
      }
      return new PlayerState {
        Session = field0,
        GhostPositions = field1,
        PlayerPositions = field2,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePlayerState, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      System.Collections.Generic.Dictionary<string, BasePosition> field1;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field1 = new System.Collections.Generic.Dictionary<string, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          string k0;
          BasePosition v0;
          k0 = reader.ReadString();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field1.Add(k0, v0);
        }
      }
      System.Collections.Generic.Dictionary<System.Guid, BasePosition> field2;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field2 = new System.Collections.Generic.Dictionary<System.Guid, BasePosition>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BasePosition v0;
          k0 = reader.ReadGuid();
          v0 = PacTheMan.Models.Position.DecodeFrom(ref reader);
          field2.Add(k0, v0);
        }
      }
      return new T {
        Session = field0,
        GhostPositions = field1,
        PlayerPositions = field2,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseError : System.IEquatable<BaseError> {
    public const uint OpCode = 0x1;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string ErrorMessage { get; set; }

    public bool Equals(BaseError other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return ErrorMessage == other.ErrorMessage;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseError baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= ErrorMessage.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseError left, BaseError right) => Equals(left, right);
    public static bool operator !=(BaseError left, BaseError  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class Error : BaseError {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseError record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseError record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseError record, ref BebopWriter writer) {
      writer.WriteString(record.ErrorMessage);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseError, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Error Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseError, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Error Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseError, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Error Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseError, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Error Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseError, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Error Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Error DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      return new Error {
        ErrorMessage = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseError, new() {
      string field0;
      field0 = reader.ReadString();
      return new T {
        ErrorMessage = field0,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseExit : System.IEquatable<BaseExit> {
    public const uint OpCode = 0x3;
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseSessionMsg Session { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Guid ClientId { get; set; }

    public bool Equals(BaseExit other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && ClientId == other.ClientId;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseExit baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Session.GetHashCode();
      hash ^= ClientId.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseExit left, BaseExit right) => Equals(left, right);
    public static bool operator !=(BaseExit left, BaseExit  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class Exit : BaseExit {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseExit record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseExit record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseExit record, ref BebopWriter writer) {
      PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      writer.WriteGuid(record.ClientId);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseExit, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Exit Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseExit, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Exit Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseExit, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Exit Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseExit, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Exit Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseExit, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Exit Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Exit DecodeFrom(ref BebopReader reader) {

      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      System.Guid field1;
      field1 = reader.ReadGuid();
      return new Exit {
        Session = field0,
        ClientId = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseExit, new() {
      BaseSessionMsg field0;
      field0 = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
      System.Guid field1;
      field1 = reader.ReadGuid();
      return new T {
        Session = field0,
        ClientId = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseGhostMove : System.IEquatable<BaseGhostMove> {
    public const uint OpCode = 0x6;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseGhostState? State { get; set; }
    #nullable disable

    public bool Equals(BaseGhostMove other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return State == other.State;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseGhostMove baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (State is not null) hash ^= State.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseGhostMove left, BaseGhostMove right) => Equals(left, right);
    public static bool operator !=(BaseGhostMove left, BaseGhostMove  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class GhostMove : BaseGhostMove {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseGhostMove record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseGhostMove record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseGhostMove record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.State is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.GhostState.EncodeInto(record.State, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseGhostMove, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMove Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseGhostMove, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMove Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseGhostMove, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMove Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseGhostMove, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMove Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseGhostMove, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static GhostMove Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static GhostMove DecodeFrom(ref BebopReader reader) {

      var record = new GhostMove();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.State = PacTheMan.Models.GhostState.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseGhostMove, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.State = PacTheMan.Models.GhostState.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseJoin : System.IEquatable<BaseJoin> {
    public const uint OpCode = 0x4;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseSessionMsg? Session { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseGhostAlgorithms? Algorithms { get; set; }
    #nullable disable

    public bool Equals(BaseJoin other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Session == other.Session && Algorithms == other.Algorithms;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseJoin baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Session is not null) hash ^= Session.GetHashCode();
      if (Algorithms is not null) hash ^= Algorithms.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseJoin left, BaseJoin right) => Equals(left, right);
    public static bool operator !=(BaseJoin left, BaseJoin  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class Join : BaseJoin {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseJoin record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseJoin record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseJoin record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Session is not null) {
        writer.WriteByte(1);
        PacTheMan.Models.SessionMsg.EncodeInto(record.Session, ref writer);
      }

      if (record.Algorithms is not null) {
        writer.WriteByte(2);
        PacTheMan.Models.GhostAlgorithms.EncodeInto(record.Algorithms, ref writer);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseJoin, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Join Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseJoin, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Join Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseJoin, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Join Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseJoin, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Join Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseJoin, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Join Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Join DecodeFrom(ref BebopReader reader) {

      var record = new Join();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseJoin, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Session = PacTheMan.Models.SessionMsg.DecodeFrom(ref reader);
            break;
          case 2:
            record.Algorithms = PacTheMan.Models.GhostAlgorithms.DecodeFrom(ref reader);
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseNetworkMessage : System.IEquatable<BaseNetworkMessage> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public uint? IncomingOpCode { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public ImmutableArray<byte> IncomingRecord { get; set; }
    #nullable disable

    public bool Equals(BaseNetworkMessage other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return IncomingOpCode == other.IncomingOpCode && (IncomingRecord == null ? other.IncomingRecord == null : other.IncomingRecord != null && IncomingRecord.SequenceEqual(other.IncomingRecord));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseNetworkMessage baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (IncomingOpCode is not null) hash ^= IncomingOpCode.Value.GetHashCode();
      if (IncomingRecord != null) hash ^= IncomingRecord.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseNetworkMessage left, BaseNetworkMessage right) => Equals(left, right);
    public static bool operator !=(BaseNetworkMessage left, BaseNetworkMessage  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class NetworkMessage : BaseNetworkMessage {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseNetworkMessage record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseNetworkMessage record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.IncomingOpCode is not null) {
        writer.WriteByte(1);
        writer.WriteUInt32(record.IncomingOpCode.Value);
      }

      if (record.IncomingRecord != null) {
        writer.WriteByte(2);
        writer.WriteBytes(record.IncomingRecord);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseNetworkMessage, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static NetworkMessage Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static NetworkMessage DecodeFrom(ref BebopReader reader) {

      var record = new NetworkMessage();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseNetworkMessage, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.IncomingOpCode = reader.ReadUInt32();
            break;
          case 2:
            record.IncomingRecord = reader.ReadBytes();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BasePosition : System.IEquatable<BasePosition> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public int X { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public int Y { get; set; }

    public bool Equals(BasePosition other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BasePosition baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= X.GetHashCode();
      hash ^= Y.GetHashCode();
      return hash;
    }

    public static bool operator ==(BasePosition left, BasePosition right) => Equals(left, right);
    public static bool operator !=(BasePosition left, BasePosition  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class Position : BasePosition {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BasePosition record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BasePosition record, ref BebopWriter writer) {
      writer.WriteInt32(record.X);
      writer.WriteInt32(record.Y);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BasePosition, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Position Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Position DecodeFrom(ref BebopReader reader) {

      int field0;
      field0 = reader.ReadInt32();
      int field1;
      field1 = reader.ReadInt32();
      return new Position {
        X = field0,
        Y = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BasePosition, new() {
      int field0;
      field0 = reader.ReadInt32();
      int field1;
      field1 = reader.ReadInt32();
      return new T {
        X = field0,
        Y = field1,
      };
    }
  }
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public abstract class BaseSessionMsg : System.IEquatable<BaseSessionMsg> {
    public const uint OpCode = 0x2;
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Guid? SessionId { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public System.Guid? ClientId { get; set; }
    #nullable disable

    public bool Equals(BaseSessionMsg other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return SessionId == other.SessionId && ClientId == other.ClientId;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSessionMsg baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (SessionId is not null) hash ^= SessionId.Value.GetHashCode();
      if (ClientId is not null) hash ^= ClientId.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSessionMsg left, BaseSessionMsg right) => Equals(left, right);
    public static bool operator !=(BaseSessionMsg left, BaseSessionMsg  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "2.0.3")]
  [BebopRecord]
  public sealed class SessionMsg : BaseSessionMsg {
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSessionMsg record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseSessionMsg record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.SessionId is not null) {
        writer.WriteByte(1);
        writer.WriteGuid(record.SessionId.Value);
      }

      if (record.ClientId is not null) {
        writer.WriteByte(2);
        writer.WriteGuid(record.ClientId.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSessionMsg, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static SessionMsg Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static SessionMsg DecodeFrom(ref BebopReader reader) {

      var record = new SessionMsg();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadGuid();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseSessionMsg, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.SessionId = reader.ReadGuid();
            break;
          case 2:
            record.ClientId = reader.ReadGuid();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }
  }
}
